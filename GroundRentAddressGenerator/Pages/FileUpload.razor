@page "/fileUpload"
@using System.IO
@using CsvHelper
@using DataLibrary.DbAccess
@using DataLibrary.DbServices
@using DataLibrary.Models
@using DataLibrary.Services
@using Microsoft.AspNetCore.Http
@using Adobe.PDFServicesSDK.auth;
@using Adobe.PDFServicesSDK.io;
@using Adobe.PDFServicesSDK.options.extractpdf;
@using Adobe.PDFServicesSDK.pdfops;
@using ExecutionContext = Adobe.PDFServicesSDK.ExecutionContext;
@using System.Globalization
@inject IDataContext dataContext
@inject IAddressDataServiceFactory addressDataServiceFactory

<div class="row mb-3 mt-3">
    <div class="container">
        <div>
            <InputFile OnChange="OnInputFileChange" multiple></InputFile>
            <button class="btn btn-primary" type="submit" @onclick="Upload">Upload</button>
            <button class="btn btn-warning" type="submit" @onclick="ExtractPdf">Extract</button>
            <button class="btn btn-warning" type="submit" @onclick="ExtractPdfTest">Extract Test (Same code as Razor)</button>
        </div>
        @if(selectedFiles is not null)
        {
            <div class="row mb-3 mt-3">
                @foreach (var file in files)
                {
                    <div class="table-striped">
                        <p>@file.File.Name</p>
                        <p>@file.File.ContentType</p>
                    </div>
                }
            </div>
        }
        <div>
            @Message
        </div>
    </div>
</div>

@code {
    private IReadOnlyList<IBrowserFile>? selectedFiles;
    private List<FileModel> files = new();
    private string Message = "No file(s) selected";
    private long maxAllowedBufferSize = 1024 * 1024 * 4;

    protected override void OnInitialized()
    {
        base.OnInitialized();
    }

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        if(files.Count > 0)
        { 
            files = new(); 
        }
        selectedFiles = e.GetMultipleFiles();
        foreach(var selectedFile in selectedFiles)
        {
            FileModel file = new();
            file.File = selectedFile;
            files.Add(file);
        }
        Message = $"{files.Count} file(s) selected";
        this.StateHasChanged();
    }

    private async void Upload()
    {
        foreach (var file in files)
        {
            using Stream stream = file.File.OpenReadStream(maxAllowedBufferSize);
            file.UploadPath = Directory.GetCurrentDirectory() + @"\wwwroot\data\" + "uploadId_" + file.File.Name;
            using FileStream fileStream = File.Create(file.UploadPath);
            var bytesRead = 0;
            var totalRead = 0;
            var buffer = new byte[1024 * 10];
            while ((bytesRead = await stream.ReadAsync(buffer)) != 0)
            {
                totalRead += bytesRead;
                await fileStream.WriteAsync(buffer, 0, bytesRead);
            }
            fileStream.Close();
            fileStream.Dispose();
            //await stream.CopyToAsync(fileStream);
            stream.Close();
        }
        Message = $"{files.Count} file(s) uploaded on server";
        this.StateHasChanged();
    }
    private void ExtractPdfTest(){
        try
        {
            Credentials credentials = Credentials.ServiceAccountCredentialsBuilder()
                .FromFile(Directory.GetCurrentDirectory() + @"\wwwroot\" + "pdfservices-api-credentials.json")
                .Build();

            ExecutionContext executionContext = ExecutionContext.Create(credentials);
            ExtractPDFOperation extractPdfOperation = ExtractPDFOperation.CreateNew();

            var path = @"wwwroot\Data\extractPDFInput.pdf";
            FileRef sourceFileRef = FileRef.CreateFromLocalFile(path);
            extractPdfOperation.SetInputFile(sourceFileRef);

            ExtractPDFOptions extractPdfOptions = ExtractPDFOptions.ExtractPDFOptionsBuilder()
                .AddCharsInfo(false)
                .AddGetStylingInfo(false)
                .AddElementsToExtract(new List<ExtractElementType>(new[] { ExtractElementType.TABLES }))
                .AddTableStructureFormat(TableStructureType.CSV)
                .Build();

            extractPdfOperation.SetOptions(extractPdfOptions);

            FileRef result = extractPdfOperation.Execute(executionContext);

            var extPath = path.Replace("extract", "resultblaze") + Guid.NewGuid().ToString() + ".zip";
            result.SaveAs(extPath);
            Message = $"Output path = {extPath}";
            this.StateHasChanged();
        }
        catch(Exception e)
        {
            Message = e.ToString();
            this.StateHasChanged();
        }

    }
    private void ExtractPdf()
    {
        try
        {
            Credentials credentials = Credentials.ServiceAccountCredentialsBuilder()
                .FromFile(Directory.GetCurrentDirectory() + @"\wwwroot\" + "pdfservices-api-credentials.json")
                .Build();

            ExecutionContext executionContext = ExecutionContext.Create(credentials);
            ExtractPDFOperation extractPdfOperation = ExtractPDFOperation.CreateNew();

            foreach(var file in files)
            {
                    FileRef sourceFileRef = FileRef.CreateFromLocalFile(file.UploadPath);
                    extractPdfOperation.SetInputFile(sourceFileRef);

                    ExtractPDFOptions extractPdfOptions = ExtractPDFOptions.ExtractPDFOptionsBuilder()
                        .AddCharsInfo(false)
                        .AddGetStylingInfo(false)
                        .AddElementsToExtract(new List<ExtractElementType>(new[] { ExtractElementType.TABLES }))
                        .AddTableStructureFormat(TableStructureType.CSV)
                        .Build();

                    extractPdfOperation.SetOptions(extractPdfOptions);
                    FileRef result = extractPdfOperation.Execute(executionContext);

                    file.ExtractPath = file.UploadPath.Replace("uploadId_", "extractId_") + ".zip";
                    result.SaveAs(file.ExtractPath);

            }
        }
        catch(Exception e)
        {
            Message = e.ToString();
            this.StateHasChanged();
        }
    }
    //private void UnzipFile()
    //{
    //    string jsonPath =
    //            @"C:\Users\Jason\source\repos\GroundRentAddressGeneratorApp\GroundRentAddressGenerator\wwwroot\Data\";

    //    ZipFile.ExtractToDirectory(request.ExtractFromFilePath, request.ExtractToFilePath);
    //    if (request.ExtractFromFilePath != null)
    //    {
    //        File.Delete(request.ExtractFromFilePath);
    //    }
    //    if (request.JsonFilePath != null)
    //    {
    //        File.Delete(request.JsonFilePath);
    //    }
    //}
    //private async void CsvParser()
    //{
    //    using (var streamReader = new StreamReader(request.FilePath))
    //    {
    //        using (var csvReader = new CsvReader(streamReader, CultureInfo.InvariantCulture))
    //        {
    //            csvReader.Context.RegisterClassMap<AddressClassMap>();
    //            while (csvReader.Read())
    //            {
    //                using (var uow = dataContext.CreateUnitOfWork())
    //                {
    //                    var record = csvReader.GetRecord<AddressModel>();
    //                    var addressDataService = addressDataServiceFactory.CreateAddressDataService(uow);
    //                    await addressDataService.CreateAddress(record);
    //                }
    //            }
    //        }
    //    }
    //}
}